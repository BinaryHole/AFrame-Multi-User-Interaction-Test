<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>AFrame Multiplayer Experience</title>

    <!-- Imports -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://aframe.io/releases/1.1.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.1.0/dist/aframe-environment-component.min.js"></script>
  </head>
  <body>
    <!-- socket.io script -->
    <script>
      var name = '';
      const socket = io({transports: ['websocket'], upgrade: false});

      // called when the player changes their name
      setName = (data) => {
        name = data.newName;
        socket.emit('setName', {name: data.newName});
      }

      // emitted when the player connects
      socket.on('connect', () => {
      });

      // emitted to update the position of all players on the client
      socket.on('updatePlayers', (data) => {
        // get the players-controller
        var playersController = document.querySelector('[players-controller]');

        // loop through each player in the data list
        for (var i = 0; i < data.players.length; i++) {
          // update the current player from the list
          playersController.emit('updatePlayer', {player: data.players[i]});
        }
      });

      // emitted at the beginning to get all currently connected players
      socket.on('spawnInitialPlayers', (data) => {
        // get the players-controller
        var playersController = document.querySelector('[players-controller]');

        // loop through each player in the data list
        for (var i = 0; i < data.players.length; i++) {
          // make sure the current player is not ourself
          if (data.players[i].id != socket.id) {
            // add the connected player from the list
            playersController.emit('addPlayer', {player: data.players[i]});
          }
        }
      });

      // emitted to add a new player on the client side
      socket.on('playerJoined', (data) => {
        document.querySelector('[players-controller]').emit(
          'addPlayer', {player: data.player});
      });

      // emitted to remove a player on the client side
      socket.on('playerQuit', (data) => {
        document.querySelector('[players-controller]').emit(
          'removePlayer', {playerId: data.playerId});
      });

      // Creates a random hex color
      const randomColor = () => {
        return('#' + Math.floor(Math.random() * 16777215).toString(16));
      }

      // allows for easily getting position as a THREE vector3
      const getPosition = (element) => {
        return element.object3D.getWorldPosition(new THREE.Vector3())
          .clone();
      }

      // allows for easily getting a rotation as a THREE quat
      const getRotation = (element) => {
        return element.object3D.getWorldQuaternion(new THREE.Quaternion())
          .clone();
      }

      // The Player component
      AFRAME.registerComponent('player', {
        schema: {
          moveThreshold: {type:'number', default: 0.1},
          rotationThreshold: {type: 'number', default: 0.1}
        },
        init: function() {
          this.ship = this.el.querySelector('.ship');

          // set up initial vars
          this.lastPosition = getPosition(this.ship);
          this.lastRotation = getRotation(this.ship);
        },

        tick: function() {
          var newPosition = getPosition(this.ship);
          var newRotation = getRotation(this.ship);

          // check if the player has moved more than the threshold amount
          if (this.hasMoved(newPosition) || this.hasRotated(newRotation)) {
            // emit a moved event to the server with the new position
            socket.emit('moved', {
              newPosition:
              {x: newPosition.x, y: newPosition.y, z: newPosition.z},
              newRotation:
              {x: newRotation.x, y: newRotation.y, z: newRotation.z,
                w: newRotation.w}});
          }
        },

        hasMoved: function(newPosition) {
          // check if the player has moved more than the threshold
          if (this.lastPosition.distanceTo(newPosition) >
            this.data.moveThreshold)
          {
            // console.log('Moved!');
            this.lastPosition = newPosition;
            return true;
          } else {
            return false;
          }
        },

        hasRotated: function(newRotation) {
          // check if the player has rotated more than the threshold
          if (Math.abs(
            THREE.MathUtils.radToDeg(this.lastRotation.angleTo(newRotation))) >
            this.data.rotationThreshold)
          {
            // console.log('Rotated!');
            this.lastRotation = newRotation;
            return true;
          } else {
            return false;
          }
        }
      });

      // The PlayerController component
      AFRAME.registerComponent('players-controller', {
        init: function () {
          var el = this.el;

          el.addEventListener('updatePlayer', function (data) {
            // get each spawned player
            var spawnedPlayers = document.querySelectorAll('[other-player]');

            // loop through each spawned player
            for (var i = 0; i < spawnedPlayers.length; i++) {
              // check if the current spawned player should be updated (by id)
              if (spawnedPlayers[i].getAttribute('id') ==
                data.detail.player.id)
              {
                // update the position of the player
                spawnedPlayers[i].setAttribute('position',
                  data.detail.player.position);

                // update the rotatino of the player
                spawnedPlayers[i].object3D.quaternion.set(
                  data.detail.player.rotation.x,
                  data.detail.player.rotation.y,
                  data.detail.player.rotation.z,
                  data.detail.player.rotation.w
                )

                // update the other-player data of the player
                spawnedPlayers[i].setAttribute('other-player', {
                  name: data.detail.player.name
                });
              }
            }
          });

          el.addEventListener('addPlayer', function (data) {
            // create a new entity element
            playerEl = document.createElement('a-entity');

            // setup the attributes of the new player element
            playerEl.setAttribute('other-player', {
              name: data.detail.player.name
            });
            playerEl.setAttribute('id', data.detail.player.id);
            playerEl.setAttribute('position', data.detail.player.position);

            playerEl.object3D.quaternion.set(
              data.detail.player.rotation.x,
              data.detail.player.rotation.y,
              data.detail.player.rotation.z,
              data.detail.player.rotation.w
            )

            console.log('Player ' + playerEl.getAttribute('id') + ' added.');

            // append the new player element to the players-controller element
            el.appendChild(playerEl);
          });

          el.addEventListener('removePlayer', function (data) {
            // get each spawned player
            var spawnedPlayers = document.querySelectorAll('[other-player]');

            // loop through each spawned player
            for (let i = 0; i < spawnedPlayers.length; i++) {
              // check if the current spawned player should be removed (by id)
              if (spawnedPlayers[i].getAttribute('id') ==
                data.detail.playerId)
              {
                console.log('Player ' + spawnedPlayers[i].getAttribute('id')
                  + ' removed.');

                // remove the spawned player
                spawnedPlayers[i].parentNode.removeChild(spawnedPlayers[i]);
              }
            }
          });
        }
      });

      // the OtherPlayer component
      AFRAME.registerComponent('other-player', {
        schema: {
          name: {type: 'string', default: ''},
          color: {type: 'color', default: 'blue'}
        },
        init: function () {
          this.el.setAttribute('geometry', {
            primitive: 'cone',
            radiusBottom: 0.7,
            radiusTop: 0.1,
            height: 1.5
          });
          this.el.setAttribute('rotation', {
            x: -90,
            y: 0,
            z: 0
          })
          this.el.setAttribute('material', {
            color: this.data.color
          });
        }
      });

      // used to modify the material of a model/mesh
      AFRAME.registerComponent('modify-material', {
        schema: {
          color: {type: 'color', default: '#fff'}
        },
        init: function () {
          this.el.addEventListener('model-loaded', () => {
            // get the mesh
            const obj = this.el.getObject3D('mesh');

            // change the material color
            obj.traverse(node => {
              console.log(this.data.color);
              node.material.color.set(this.data.color);
            });
          });
        }
      });
    </script>

    <a-scene>
      <a-assets>
        <a-asset-item id='spaceship' src='/assets/DS3_A3_Spaceship.glb'>
        </a-asset-item>
        <img id='space' src='/assets/hdri.png'></img>
      </a-assets>

      <a-sky src='#space'></a-sky>

      <a-entity wasd-controls='fly:true' look-controls player>
        <a-cone class='ship'
          color='#2d5aae'
          radius-bottom='0.7'
          radius-top='0.1'
          height='1.5'
          rotation='-90 0 0'
        ></a-cone>
        <a-entity camera position='0 2 5'></a-entity>
      </a-entity>
      <a-entity players-controller></a-entity>
      <!-- <a-entity environment='ground: none; skyType: none'></a-entity> -->
    </a-scene>
  </body>
</html>
